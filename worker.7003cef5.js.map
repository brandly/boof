{"version":3,"sources":["program.ts","worker.tsx"],"names":[],"mappings":"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","file":"worker.7003cef5.js","sourceRoot":"../src","sourcesContent":["const maxCellVal = 256\n\nexport type State = {\n  index: number\n  pointer: number\n  tape: number[]\n  output: number[]\n}\n\nexport type Token = {\n  char: string\n  line: number\n  column: number\n}\n\nexport type Log = {\n  before: State\n  token: Token\n  after: State\n}\n\nconst valid = new Set('><+-[].,'.split(''))\nconst tokenize = (src: string) => {\n  const chars = src.split('')\n\n  let line = 0\n  let column = 0\n  const tokens = chars.map((char, i) => {\n    const t = {\n      char,\n      line,\n      column\n    }\n\n    if (char === '\\n') {\n      column = 0\n      line++\n    } else {\n      column++\n    }\n    return t\n  })\n\n  return tokens.filter(t => valid.has(t.char))\n}\n\nexport class Program {\n  src: string\n  tokens: Token[]\n  state: State\n  history: Log[]\n\n  constructor(src: string) {\n    this.src = src\n    this.tokens = tokenize(src)\n    this.state = {\n      index: 0,\n      pointer: 0,\n      tape: [0],\n      output: []\n    }\n    this.history = []\n  }\n\n  run(input: string = '', debug: boolean = false) {\n    const inputChars = input.split('')\n    while (!this.hasFinished()) {\n      let before = this.state\n      let token = this.tokens[this.state.index]\n      this.state = advance(consume(this.tokens, this.state, inputChars))\n      this.history.push({\n        before,\n        token,\n        after: this.state\n      })\n      debug &&\n        console.log(\n          this.src[this.state.index - 1],\n          '\\n',\n          this.state.tape\n            .map((c, i) => (i === this.state.pointer ? `(${c})` : c.toString()))\n            .join(' ')\n        )\n    }\n    return this\n  }\n\n  print() {\n    return this.state.output.map(char => String.fromCharCode(char)).join('')\n  }\n\n  hasFinished() {\n    return this.state.index >= this.tokens.length\n  }\n}\n\nfunction advance(s: State): State {\n  return { ...s, index: s.index + 1 }\n}\nfunction consume(tokens: Token[], state: State, input: string[]): State {\n  const { char } = tokens[state.index]\n  const { tape, pointer, output } = state\n\n  switch (char) {\n    case '>': {\n      const newTape = tape.slice(0)\n      const newPointer = pointer + 1\n      newTape[newPointer] = newTape[newPointer] || 0\n      return {\n        ...state,\n        tape: newTape,\n        pointer: newPointer\n      }\n    }\n    case '<': {\n      const updated = pointer - 1\n      if (updated < 0) {\n        // TODO: improve this error, provide inline feedback\n        throw new Error('Invalid tape pointer')\n      }\n      return {\n        ...state,\n        pointer: updated\n      }\n    }\n    case '+': {\n      const newTape = tape.slice(0)\n      newTape[pointer] = ((newTape[pointer] || 0) + 1) % maxCellVal\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    case '-': {\n      const newTape = tape.slice(0)\n      newTape[pointer] = (newTape[pointer] || 0) - 1\n      if (newTape[pointer] < 0) {\n        newTape[pointer] = newTape[pointer] + maxCellVal\n      }\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    case '[': {\n      if (!tape[pointer]) {\n        let depth = 1\n        let { index } = state\n        while (depth > 0) {\n          index += 1\n          if (tokens[index].char === '[') {\n            depth += 1\n          } else if (tokens[index].char === ']') {\n            depth -= 1\n          }\n        }\n        return {\n          ...state,\n          index\n        }\n      } else {\n        return state\n      }\n    }\n    case ']': {\n      let depth = 1\n      let { index } = state\n      while (depth > 0) {\n        index -= 1\n        if (tokens[index].char === '[') {\n          depth -= 1\n        } else if (tokens[index].char === ']') {\n          depth += 1\n        }\n      }\n      index -= 1\n      return {\n        ...state,\n        index\n      }\n    }\n    case '.': {\n      return {\n        ...state,\n        output: output.concat(tape[pointer] || 0)\n      }\n    }\n    case ',': {\n      const val = (input.shift() || '\\0').charCodeAt(0)\n      const newTape = tape.slice(0)\n      newTape[pointer] = val\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    default:\n      return state\n  }\n}\n","import * as Program from './program'\n\nself.onmessage = (e: { data: { src: string; input: string } }) => {\n  const { src, input } = e.data\n  const program = new Program.Program(src)\n  program.run(input)\n  self.postMessage(\n    {\n      output: program.print(),\n      summaries: summariesPerLine(program.history),\n      state: program.state\n    },\n    []\n  )\n}\n\nfunction summarize(history: Program.Log[]): string {\n  const { before } = history[0]\n  const { after } = history[history.length - 1]\n\n  const cellChanges: string[] = []\n  for (let i = 0; i < Math.max(before.tape.length, after.tape.length); i++) {\n    const diff: number = after.tape[i] - (before.tape[i] || 0)\n    const verb = diff > 0 ? 'Add' : 'Subtract'\n    const preposition = diff > 0 ? 'to' : 'from'\n    cellChanges.push(\n      diff === 0 ? '' : `${verb} ${Math.abs(diff)} ${preposition} c${i}`\n    )\n  }\n\n  const prints: string = after.output\n    .slice(before.output.length)\n    .map((char: number) => String.fromCharCode(char))\n    .join('')\n  const printed: string = prints.length ? `Print ${JSON.stringify(prints)}` : ''\n  return cellChanges\n    .concat(printed)\n    .filter(Boolean)\n    .join('. ')\n}\n\nfunction changeSequencesPerLine(history: Program.Log[]): Program.Log[][][] {\n  return history.reduce((result: Program.Log[][][], log, index) => {\n    if (index === 0 || log.token.line !== history[index - 1].token.line) {\n      if (!result[log.token.line]) {\n        result[log.token.line] = []\n      }\n      result[log.token.line].push([])\n    }\n    const forLine = result[log.token.line]\n    forLine[forLine.length - 1].push(log)\n    return result\n  }, [])\n}\n\nconst nbsp = '\\u00A0'\ntype SummaryCount = { [summary: string]: number }\nfunction summariesPerLine(history: Program.Log[]): string[] {\n  return changeSequencesPerLine(history).map(line => {\n    const summaries = line.map(seq => summarize(seq))\n    const summaryToCount: SummaryCount = summaries.reduce(\n      (map: SummaryCount, summary) => {\n        if (!summary) return map\n        if (!map[summary]) map[summary] = 0\n        map[summary] += 1\n        return map\n      },\n      {}\n    )\n    return (\n      Object.keys(summaryToCount)\n        .map(\n          summary =>\n            `${summary}` +\n            (summaryToCount[summary] > 1 ? ` x${summaryToCount[summary]}` : '')\n        )\n        .join(' ~~ ') || nbsp\n    )\n  })\n}\n"]}