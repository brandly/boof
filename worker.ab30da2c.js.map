{"version":3,"sources":["util.ts","program.ts","worker.js"],"names":["self","onmessage","e","data","src","input","program","Program","run","postMessage","output","print","hasFinished"],"mappings":"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","file":"worker.ab30da2c.js","sourceRoot":"..","sourcesContent":["\nexport const includes = (list, val) => list.indexOf(val) !== -1\n","import { includes } from './util'\n\nconst maxCellVal = 256\n\ninterface State {\n  index: number,\n  pointer: number,\n  tape: number[],\n  output: number[]\n}\n\ninterface Token {\n  char: string,\n  line: number,\n  column: number\n}\n\ninterface Log {\n  before: State,\n  token: Token,\n  after: State\n}\n\nconst valid = '><+-[].,'\nconst tokenize = (src: string) => {\n  const chars = src.split('')\n\n  let line = 0\n  let column = 0\n  const tokens = chars.map((char, i) => {\n    const t = {\n      char,\n      line,\n      column\n    }\n\n    if (char === '\\n') {\n      column = 0\n      line++\n    } else {\n      column++\n    }\n    return t\n  })\n\n  return tokens.filter(t => includes(valid, t.char))\n}\n\nexport class Program {\n  src: string;\n  tokens: Token[];\n  state: State;\n  history: Log[];\n\n  constructor (src: string) {\n    this.src = src\n    this.tokens = tokenize(src)\n    this.state = {\n      index: 0,\n      pointer: 0,\n      tape: [0],\n      output: []\n    }\n    this.history = []\n  }\n\n  run (input: string = '', debug: boolean = false) {\n    const inputChars = input.split('')\n    while (!this.hasFinished() && this.history.length < 100000) {\n      let before = this.state\n      let token = this.tokens[this.state.index]\n      this.state = advance(consume(this.tokens, this.state, inputChars))\n      this.history.push({\n        before,\n        token,\n        after: this.state\n      })\n      debug && console.log(\n        this.src[this.state.index - 1],\n        '\\n',\n        this.state.tape\n          .map((c, i) =>\n            i === this.state.pointer ? `(${c})` : c.toString()\n          )\n          .join(' ')\n       )\n    }\n    return this\n  }\n\n  print () {\n    return this.state.output.map(char => String.fromCharCode(char)).join('')\n  }\n\n  hasFinished () {\n    return this.state.index >= this.tokens.length\n  }\n}\n\nfunction advance (s: State): State { return { ...s, index: s.index + 1 } }\nfunction consume (tokens: Token[], state: State, input: string[]): State {\n  const { char } = tokens[state.index]\n  const { tape, pointer, output } = state\n\n  switch (char) {\n    case '>': {\n      const newTape = tape.slice(0)\n      const newPointer = pointer + 1\n      newTape[newPointer] = newTape[newPointer] || 0\n      return {\n        ...state,\n        tape: newTape,\n        pointer: newPointer\n      }\n    }\n    case '<': {\n      const updated = pointer - 1\n      if (updated < 0) {\n        // TODO: improve this error, provide inline feedback\n        throw new Error('Invalid tape pointer')\n      }\n      return {\n        ...state,\n        pointer: updated\n      }\n    }\n    case '+': {\n      const newTape = tape.slice(0)\n      newTape[pointer] = ((newTape[pointer] || 0) + 1) % maxCellVal\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    case '-': {\n      const newTape = tape.slice(0)\n      newTape[pointer] = (newTape[pointer] || 0) - 1\n      if (newTape[pointer] < 0) {\n        newTape[pointer] = newTape[pointer] + maxCellVal\n      }\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    case '[': {\n      if (!tape[pointer]) {\n        let depth = 1\n        let { index } = state\n        while (depth > 0) {\n          index += 1\n          if (tokens[index].char === '[') {\n            depth += 1\n          } else if (tokens[index].char === ']') {\n            depth -= 1\n          }\n        }\n        return {\n          ...state,\n          index\n        }\n      } else {\n        return state\n      }\n    }\n    case ']': {\n      let depth = 1\n      let { index } = state\n      while (depth > 0) {\n        index -= 1\n        if (tokens[index].char === '[') {\n          depth -= 1\n        } else if (tokens[index].char === ']') {\n          depth += 1\n        }\n      }\n      index -= 1\n      return {\n        ...state,\n        index\n      }\n    }\n    case '.': {\n      return {\n        ...state,\n        output: output.concat(tape[pointer] || 0)\n      }\n    }\n    case ',': {\n      const val = (input.shift() || '\\0').charCodeAt(0)\n      const newTape = tape.slice(0)\n      newTape[pointer] = val\n      return {\n        ...state,\n        tape: newTape\n      }\n    }\n    default:\n      return state\n  }\n}\n","import { Program } from './program'\n\nself.onmessage = e => {\n  const { src, input } = e.data\n  const program = new Program(src)\n  program.run(input)\n  self.postMessage({\n    output: program.print(),\n    hasFinished: program.hasFinished()\n  })\n}\n"]}